\documentclass[11pt]{article}

% Packages
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{dingbat}

% Colors
\definecolor{mygray}{RGB}{235,235,235}

% Margins
\setlength{\topmargin}{-2cm}
\setlength{\textwidth}{16.5cm}
\setlength{\textheight}{24cm}
\setlength{\evensidemargin}{0cm}
\setlength{\oddsidemargin}{0cm}

% Fix link colors
\hypersetup{
    colorlinks = true,
    linkcolor=red,
    citecolor=red,
    urlcolor=blue,
    linktocpage % so that page numbers are clickable in toc
}


% Code listings
\lstset{
  basicstyle=\ttfamily,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color{magenta}\ttfamily,
  morecomment=[l][\color{magenta}]{\#}
}

\lstnewenvironment{cli}
                  {\footnotesize
                    \lstset{columns=fullflexible,
                      language=bash,
                      backgroundcolor=\color{mygray}
                  }}
{}

\lstnewenvironment{xml}
                  {\footnotesize
                    \lstset{columns=fullflexible,
                      language=XML,
                      backgroundcolor=\color{Salmon},
                      morekeywords={property,name,value,description,configuration}
                  }}
{}
               
% Notes and TODOs              
\newcommand{\postit}[1]{
  \noindent
  \fcolorbox{red}{yellow}{%
    \begin{minipage}{5cm}
      #1
    \end{minipage}
   }
}

\title{\textsc{Data Communications \& Computer Networks (COMP 445)} \\ Winter 2017 \\ Laboratory assignment \#3 \\ A peer-to-peer chat application based on UDP}

\author{Tristan Glatard\\Department of Computer Science and Software Engineering\\Concordia University, Montreal\\\href{mailto:tristan.glatard@concordia.ca}{tristan.glatard@concordia.ca}}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Introduction}

In this assignment we will create a peer-to-peer chat application
where all peers write messages to a common chat room. Peers will
communicate in a completely decentralized manner, without a central
server. Such a decentralized approach provides robustness and privacy,
although the communication mechanism is perhaps more challenging than in a
client-server architecture.

Peers will communicate by broadcasting messages
in the network over UDP. We will develop a simple application-level
protocol to allow peers to join the network, send public and (as a
bonus) private messages among each other, and leave the network.

You may use any language supporting sockets, for instance
Python, Java, C, JavaScript or Go. 

\section{Basic architecture}
\label{sec:architecture}

We will first implement the basic communication mechanism between
peers. Our chat application must be able to send \emph{and} receive
messages through UDP sockets. Thus, it will consist of a
sender and a receiver implemented in two separate processes or
threads. The sender and receiver will share a common terminal
window. The sender will read messages typed by the user in the
terminal and send them to other peers. The receiver will receive
messages sent by other peers and display them in the terminal. 

Algorithm~\ref{algo:basic} shows the basic architecture of the
application using the following notations:
\begin{itemize}
\item \texttt{ip\_address} is the IP address where the messages will
  be sent. Use \texttt{localhost} (or \texttt{127.0.0.1}) in this
  Section. In Section~\ref{sec:broadcast} we will use a broadcast
  address instead.
  \item \texttt{port} is the port number used by your application. Choose any
    number higher than 1024. Of course, all the peers will have to use
    the same port number.
  \item \texttt{s} is a UDP socket, created and used as in slides 98
    (client) and 99 (server) of the lecture about the Application
    Layer. Remember that UDP is a connectionless protocol, i.e., you
    mustn't use any \texttt{connect}, \texttt{listen} or
    \texttt{accept} function.
    \item \texttt{read\_text\_from\_user\_input()} is a function that
      reads text typed by the user in the terminal window, e.g.,
      \texttt{raw\_input} in Python.
    \item \texttt{build\_message} is a function that you must write to
      build an application message from the user name and message. You
      can define the application message format as you wish. The following simple format is suggested, where the user name and message both appear as a single line prefixed with \texttt{user:} or \texttt{message:} and the message ends with a blank line:
\begin{verbatim}
  user:<username>\n
  message:<message>\n
  \n
\end{verbatim}
It is assumed that messages do not contain any newline character.
\item \texttt{parse\_message} is a function that you must write to extract the user name and user message from an application message. It is strongly dependent on the application message format adopted by \texttt{build\_message}.
\item \texttt{print} is a function that you must write to print a user message and name on the console. 
\end{itemize}
\begin{algorithm}[htb]
  \caption{Basic chat sender and receiver using UDP sockets}
  \label{algo:basic}
\begin{algorithmic}[1]
  \Procedure{Sender}{user\_name,ip\_address,port}
  \State s=udp\_socket()
  \While{True}
  \State user\_message=read\_text\_from\_user\_input()
  \State application\_message=build\_message(user\_message,user\_name)
  \State s.sendto(application\_message,ip\_address,port)
  \EndWhile
  \EndProcedure
  \Procedure{Receiver}{port}
  \State s=udp\_socket()
  \State s.bind('',port)
  \While{True}
  \State application\_message = s.receive()
  \State (user\_name,user\_message) = parse\_message(application\_message)
  \State print(user\_name,user\_message)
  \EndWhile
  \EndProcedure
\end{algorithmic}
\end{algorithm}

\leftpointright Implement a chat application based on the architecture
described above. Figure~\ref{fig:architecture} shows an example of a
chat session that your application must support at this point.
\begin{figure}
\begin{cli}
$ chat 
Enter your name: Tristan
hi
2017-03-18 13:36:53.800411 [Tristan]: hi
I am here
2017-03-18 13:37:01.637381 [Tristan]: I am here
\end{cli}
\caption{Example of a chat session that your application must support
  once you completed Section~\ref{sec:architecture}. Only one user is
  active here. The sender process reads messages typed in the terminal
  and send them to the receiver process through UDP sockets. The
  receiver parses the user name and message and prints them in the terminal.}
\label{fig:architecture}
\end{figure}

\section{Broadcast}
\label{sec:broadcast}
The application developed so far only sends messages to the local
host, which is of limited interest for a chat application. To allow
multiple peers to communicate together, the sender must broadcast
messages to all the peers in the chat network. We will
implement that using broadcast IP addresses. Two broadcast
addresses are available on a sub-net with IP address \texttt{x,y,z.0}:
\begin{itemize}
\item \texttt{255.255.255.255} is the broadcast address associated
  with ``this network'', i.e., the network with address 0.0.0.0. IP
  datagrams with this destination IP address are not forwarded by
  routers to other networks.
\item \texttt{x.y.z.255} is the broadcast address associated with
  sub-net \texttt{x.y.z.0}. It can be used by hosts located outside of
  the sub-net to broadcast messages to all the hosts in the sub-net.
\end{itemize}

\leftpointright Modify your program to use one of these two broadcast
addresses. Note that in most languages you will have to call the
\texttt{setsockopt} function on the sender's socket to enable
broadcasts. For instance, the Python command would be
\texttt{s.setsockopt(SOL\_SOCKET, SO\_BROADCAST, 1)}. Your program
must behave exactly the same as in Section~\ref{sec:architecture}, except that
it now uses a broadcast IP address internally. 

%\postit{ multicast could be
%used instead of broadcast.}

\section{Setup with multiple peers}

We will now test our program with multiple peers. A realistic and
relatively easy way to do so is to use the
\href{http://www.docker.com}{Docker} container system. Docker is a
widely-used technology to start containers (lightweight virtual
machines) on your computer.

\leftpointright Follow the procedure below to test your chat
application with multiple peers:
\begin{enumerate}
  \item Install Docker from \url{https://www.docker.com} and make sure
    you can start a simple Linux container, e.g., using the
    \texttt{centos:latest} image. Installation
    instructions and tutorials are available for Linux, Mac and
    Windows.
  \item Start two (or more) Docker containers and check that their
    IP addresses are in the same sub-net, e.g., \texttt{172.17.0.5} and
    \texttt{172.17.0.4}. You can use this
    command line to start a container:
    \begin{cli}
      $ docker run --rm -it centos:latest  /bin/bash
    \end{cli}
    You can check the IP address of a container using the
    \texttt{ifconfig} command-line tool.
  \item Run your chat application from two (or more) containers to
    produce a session such as shown on Figure~\ref{fig:docker}. To
    access your program file(s) from the container, it is recommended
    to mount a directory of your computer in the container. You can
    use the following command line:
    \begin{cli}
      $ docker run --rm -it -v $PWD:/run -w /run -u $UID centos:latest  /bin/bash
    \end{cli}
\end{enumerate}

\begin{figure}[h]
\textbf{Peer 1:}
\begin{cli}
$ chat
Enter your name: Tristan
2017-03-18 18:10:00.656378 [Glatard]: hi everybody
salut
2017-03-18 18:10:04.374133 [Tristan]: salut
\end{cli}
\textbf{Peer 2:}
\begin{cli}
  $ chat
Enter your name: Glatard
hi everybody
2017-03-18 18:10:00.656088 [Glatard]: hi everybody
2017-03-18 18:10:04.374361 [Tristan]: salut
\end{cli}
\caption{Chat session with two peers located in two Docker containers.}
\label{fig:docker}
\end{figure}

\section{First protocol commands: TALK and JOIN}

We will now enhance our application by adding extra commands to our
basic protocol. For this purpose, a \texttt{command} field will be
added to the application message format, using for instance the
following syntax:
\begin{verbatim}
  user:<username>\n
  command:<command-name>\n
  message:<message>\n
  \n
\end{verbatim}
Function \texttt{build\_message} must be modified accordingly, to
take the command name as a parameter. Similarly, function
\texttt{parse\_message} must be modified to return the command name. 

\leftpointright Implement a \texttt{TALK} and a \texttt{JOIN} command
in your protocol. Application messages containing user messages (as
implemented in the previous Sections) must now use the \texttt{TALK}
command. When the application starts, the sender must now
broadcast a \texttt{JOIN} message. When a receiver receives a
\texttt{JOIN} message, it must print a message indicating that a user
has joined the network. The receiver must reject any command other
than \texttt{TALK} and \texttt{JOIN}.

A session of your chat application should now look like the sample in Figure~\ref{fig:talk-join}.
\begin{figure}
\textbf{Peer 1:}
\begin{cli}
$ chat
Enter your name: Tristan
2017-03-18 19:31:38.152550 Tristan joined!
hi
2017-03-18 19:31:39.568304 [Tristan]: hi
2017-03-18 19:31:44.084659 Glatard joined!
2017-03-18 19:31:45.352232 [Glatard]: hi
\end{cli}
\textbf{Peer 2:}
\begin{cli}
 $ chat 
Enter your name: Glatard
2017-03-18 19:31:44.084595 Glatard joined!
hi
2017-03-18 19:31:45.352329 [Glatard]: hi
\end{cli}
\caption{Sample chat session illustrating the \texttt{TALK} and \texttt{JOIN} commands (see \texttt{<username> joined!} messages).}
\label{fig:talk-join}
\end{figure}

\section{User-triggered command: LEAVE}

We will now add a \texttt{LEAVE} command used by a peer to notify that
it is leaving the chat room. This command will be triggered when the
user types \texttt{/leave} in the command prompt. That is, the sender
must parse the content of \texttt{user\_message} created on line 5 of
Algorithm~\ref{algo:basic} and broadcast a \texttt{LEAVE} command instead
of a \texttt{TALK} command when \texttt{user\_message} is
\texttt{/leave}. When it receives a \texttt{LEAVE} command, the receiver
must print a message showing that a particular user left the chat room.

\leftpointright Implement the \texttt{LEAVE} command. A session of your chat application should now look like the one in Figure~\ref{fig:leave}.

\begin{figure}[h]
\textbf{Peer 1:}
\begin{cli}
$ chat 
Enter your name: Tristan
2017-03-18 19:37:06.681251 Tristan joined!
hi
2017-03-18 19:37:10.615165 [Tristan]: hi
2017-03-18 19:37:15.222976 Glatard joined!
2017-03-18 19:37:17.170153 [Glatard]: hi
/leave
2017-03-18 19:37:21.869671 Tristan left!
\end{cli}
\textbf{Peer 2:}
\begin{cli}
$ chat
Enter your name: Glatard
2017-03-18 19:37:15.222911 Glatard joined!
hi
2017-03-18 19:37:17.169884 [Glatard]: hi
2017-03-18 19:37:21.869865 Tristan left!
/leave
2017-03-18 19:37:25.425479 Glatard left!
\end{cli}
\caption{Chat session illustrating the \texttt{LEAVE} command (see \texttt{<username> left!} messages).}
\label{fig:leave}
\end{figure}

\section{Local commands: WHO and QUIT}

We will add two new commands in this Section. These commands are local
in the sense that they are not broadcast to all receivers in the
network but rather sent to the local receiver only.  \texttt{WHO} is a
user-triggered command that prints a list of connected
users\footnote{You may wonder what ``connected'' might mean here. It
  certainly does \emph{not} mean that a TCP connection has been
  established! Instead, in our application-level chat protocol, a user
  is said to be connected after it sent a \texttt{JOIN} message and
  before it sent a \texttt{LEAVE} message. Since UDP is not a reliable
  protocol, you are encouraged to think of the consequences of loosing
  such a \texttt{JOIN} or \texttt{LEAVE} message.}. When the user
types \texttt{/who} in the message prompt, the sender sends a
\texttt{WHO} command to the receiver \emph{on the same host
  only}. When the receiver receives a \texttt{WHO} command, it simply
prints a list of connected users. This list is initialized to the
empty list when the receiver starts. Anytime the receiver receives a
\texttt{JOIN} command, it adds the corresponding user to the list. Any
time it receives a \texttt{LEAVE} command, it removes the
corresponding user from the list.

The \texttt{QUIT} command is also local, i.e., it is never sent as a
broadcast. The \texttt{QUIT} command is sent by the sender to the
receiver to specify that the receiver must exit. The sender sends a
local \texttt{QUIT} command after the \texttt{LEAVE} command is sent, i.e.,
as a result of a \texttt{/leave} message entered in the message
prompt. When the receiver receives a \texttt{QUIT} command, it prints
a message and exits properly.

\leftpointright Implement the local \texttt{WHO} and \texttt{QUIT} commands. A session of your chat application should now look like the one in Figure~\ref{fig:who-quit}.

\begin{figure}[h]
\textbf{Peer 1:}
\begin{cli}
$ chat
Enter your name: Tristan
2017-03-18 19:47:45.728726 Tristan joined!
hi
2017-03-18 19:47:46.867741 [Tristan]: hi
/who
2017-03-18 19:47:49.814319 Connected users: ['Tristan']
2017-03-18 19:47:55.917692 Glatard joined!
2017-03-18 19:47:58.941634 [Glatard]: hi
/who
2017-03-18 19:48:01.612203 Connected users: ['Tristan', 'Glatard']
2017-03-18 19:48:05.857700 Glatard left!
/who
2017-03-18 19:48:08.918587 Connected users: ['Tristan']
/leave
2017-03-18 19:48:12.924641 Tristan left!
Bye now!
\end{cli}
\textbf{Peer 2:}
\begin{cli}
$ chat
Enter your name: Glatard
2017-03-18 19:47:55.917857 Glatard joined!
hi
2017-03-18 19:47:58.941479 [Glatard]: hi
/leave
2017-03-18 19:48:05.857470 Glatard left!
Bye now!  
\end{cli}
\caption{Chat session illustrating the \texttt{WHO} and \texttt{QUIT}
  local commands. \texttt{/who} returns a list of connected users that
  updates correctly when a user joins or leaves the chat room. The
  receiver exits properly when the \texttt{/leave} command is typed
  (see \texttt{Bye now!} messages).}
\label{fig:who-quit}
\end{figure}

\section{Receiver responses: PING}

You may have noticed that a peer joining the chat room has no way to
learn about the current list of active peers. That is,
a newly arrived peer will always see a singleton as a result of the
\texttt{WHO} command. To remedy this issue, we will now add a
\texttt{PING} command. The \texttt{PING} command is sent as a
broadcast \emph{by the receiver} after it received a \texttt{JOIN}
command. Its sole purpose is to
advertise the presence of the receiver's peer to the newly arrived
peer. When a receiver receives a \texttt{PING} command, it just adds
the sender's user name to its list of connected users (the list
printed by the \texttt{/who} command).

\leftpointright Implement the \texttt{PING} command. 
A session of your chat application should now look like the one in Figure~\ref{fig:ping}.
\begin{figure}[h]
\textbf{Peer 1:}
\begin{cli}
  $ chat
Enter your name: Tristan
2017-03-18 19:55:11.057321 Tristan joined!
hi
2017-03-18 19:55:28.910119 [Tristan]: hi
2017-03-18 19:55:32.453516 [Glatard]: hi
2017-03-18 19:55:34.801339 Glatard left!
/leave
2017-03-18 19:55:38.074736 Tristan left!
Bye now!
\end{cli}
\textbf{Peer 2:}
\begin{cli}
$ chat
Enter your name: Glatard
2017-03-18 19:55:16.047899 Glatard joined!
/who
2017-03-18 19:55:23.518658 Connected users: ['Tristan', 'Glatard']
2017-03-18 19:55:28.910239 [Tristan]: hi
hi
2017-03-18 19:55:32.453306 [Glatard]: hi
/leave
2017-03-18 19:55:34.803277 Glatard left!
Bye now!
\end{cli}
\caption{A chat session illustrating the \texttt{PING} command. When a
  new peer joins the network, it now receives a \texttt{PING} message
  from all the peers in the network so that the \texttt{/who} list is
  properly updated.}
\label{fig:ping}
\end{figure}

\section{Bonuses}

\subsection{Unicast communication: private messages}

When the user types \texttt{/private <username>} in the message
prompt, the subsequent message must be sent to \texttt{<username>}
only, i.e., it must not be sent as a broadcast. To implement this, the
receiver has to store the list of IP addresses in addition to user
names. Private messages should be sent with a new
\texttt{PRIVATE-TALK} command. The \texttt{PRIVATE-TALK} command may
be sent either directly by the sender to the addressee of the private
message (in this case the sender has to retrieve the IP address from
its receiver) or from the sender to its local receiver and then from
the local receiver to the remote receiver. Of course,
\texttt{PRIVATE-TALK} commands must never be sent as broadcast
messages.

\leftpointright Implement private discussions. Figure~\ref{fig:private} shows a chat session illustrating this functionality.
\begin{figure}
\textbf{Peer 1:}
\begin{cli}
$ chat
Enter your name: Glatard
2017-03-18 20:05:49.390689 Glatard joined!
hi
2017-03-18 20:05:51.536567 [Glatard]: hi
/who
2017-03-18 20:05:54.927527 Connected users: ['Tristan', 'Glatard']
/private Tristan
Private message to Tristan: hi Tristan
/leave
2017-03-18 20:06:06.820172 Glatard left!
Bye now!
\end{cli}
\textbf{Peer 2:}
\begin{cli}
$ chat
Enter your name: Tristan
2017-03-18 20:05:40.831882 Tristan joined!
2017-03-18 20:05:49.390734 Glatard joined!
2017-03-18 20:05:51.536801 [Glatard]: hi
2017-03-18 20:06:02.463223 [Glatard] (PRIVATE): hi Tristan
2017-03-18 20:06:06.811674 Glatard left!
\end{cli}
\caption{Chat session illustrating private messages.}
\label{fig:private}
\end{figure}

\subsection{Channels}

Here we add a \texttt{channel} field to the application message format
to allow (1) a sender to send messages labeled with a particular
channel name and (2) a receiver to display messages that are related
only to a particular channel. Channel change will be implemented by
typing \texttt{/channel <channel\_name>} in the message prompt. The
receiver will  print the channel name with every received
messages. A default channel called \texttt{general} must be used when
the application starts.

\leftpointright Implement channels. Figure~\ref{fig:channels} shows a chat session illustrating this functionality.
\begin{figure}
\textbf{Peer 1:}
\begin{cli}
$ chat 
Enter your name: Tristan
2017-03-18 20:12:44.068235 Tristan joined!
hi, this is the general channel
2017-03-18 20:12:49.890597 [Tristan #general]: hi, this is the general channel
/channel food
2017-03-18 20:12:56.290560 Switched to channel food
is anyone here?
2017-03-18 20:13:00.502537 [Tristan #food]: is anyone here?
2017-03-18 20:13:09.024392 [Glatard #food]: hi there!
hi, good to see you in the #food channel!
2017-03-18 20:13:33.432564 [Tristan #food]: hi, good to see you in the #food channel!
\end{cli}
\textbf{Peer 2:}
\begin{cli}
 $ chat
Enter your name: Glatard
2017-03-18 20:12:40.297073 Glatard joined!
2017-03-18 20:12:44.068323 Tristan joined!
2017-03-18 20:12:49.890797 [Tristan #general]: hi, this is the general channel
/channel food
2017-03-18 20:13:05.348852 Switched to channel food
hi there!
2017-03-18 20:13:09.023945 [Glatard #food]: hi there!
2017-03-18 20:13:33.432826 [Tristan #food]: hi, good to see you in the #food channel!
\end{cli}
\caption{A chat session illustrating channels. Note the channel name displayed after the \texttt{\#} sign.}
\label{fig:channels}
\end{figure}

\subsection{Unique user names}

Improve your application so that multiple users with the same user
name can co-exist consistently. In particular, private messages must be
delivered to the right users.

\section{Assignment submission and marking}

\subsection{Submission format}

You can submit this assignment individually or in a group of at most
two members. No extra marks or any special considerations will be given
for working individually.

The source code implementing your chat application must be submitted
on Moodle by the deadline specified in the course outline. You must
submit a \texttt{tgz} or \texttt{zip} archive containing all your
source files as well as a README file explaining how to compile (if
relvant) and run your application. Your archive name must contain your student ID and the student ID of your team mate if relevant. 

\subsection{Demo}

A demo is needed for this assignment and your lab instructors will
communicate the available demo times to you, where you must register a
time-slot for the demo. You must prepare your assignment and be ready
to demo at the start of your time-slot. If the assignment is done by 2
members, then both members must be present for the demo.  During your
presentation, you are expected to demo the functionality of the
application, explain some parts of your implementation, and answer any
questions that the lab instructor may ask in relation to the
assignment and your work. Different marks may be assigned to the two
members of the team if needed. Demos are mandatory. Failure to demo
your assignment will entail a mark of zero for the assignment. Failure
to show up for a scheduled demo will entail you to a zero marks as no
replacement of a demo time is/will be allowed.

\subsection{Marking policy}

\begin{itemize}
\item Basic architecture: 2 points
\item Broadcast: 1 point
\item Setup with multiple peers: 2 points
\item TALK and JOIN: 2 points
\item LEAVE: 1 point
\item WHO and QUIT: 1 points
\item PING: 1 points
\end{itemize}

\textbf{Bonuses:}
\begin{itemize}
\item Private messages: 2 points
\item Channels: 1 point
\item Unique user names: 2 points
\end{itemize}

\end{document}


